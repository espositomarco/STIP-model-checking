--inizio



MODULE main
    DEFINE
        num_cars := #{num_cars};
        --throttle#{} := 1;
        --brake := -3;
        --conflict := [ [ [1,1,1,1] , [1,1,1,1] ] , [  ] ]
        THETA := -1;
        conflict := [[[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 1, 1, 1], [0, 0, 1, 1], [3, 3, 0, 1], [2, 2, 2, 0]], [[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [2, 2, 2, 0]], [[0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1], [0, 0, 0, 0]]], [[[0, 0, 0, 0], [1, 0, 1, 1], [1, 0, 0, 1], [1, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 2, 2, 2], [1, 0, 1, 1], [1, 0, 0, 1], [1, 3, 3, 0]], [[0, 2, 2, 2], [1, 0, 1, 1], [1, 0, 0, 1], [1, 0, 0, 0]]], [[[0, 1, 0, 0], [2, 0, 2, 2], [1, 1, 0, 1], [1, 1, 0, 0]], [[0, 1, 0, 0], [0, 0, 0, 0], [1, 1, 0, 1], [1, 1, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 1, 3, 3], [2, 0, 2, 2], [1, 1, 0, 1], [1, 1, 0, 0]]], [[[0, 1, 1, 0], [3, 0, 1, 3], [2, 2, 0, 2], [1, 1, 1, 0]], [[0, 1, 1, 0], [0, 0, 1, 0], [2, 2, 0, 2], [1, 1, 1, 0]], [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0], [1, 1, 1, 0]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]];


    --FROZENVAR
        --conflict : array 1..4 of array 1..4 of array 1..4 of array 1..4 of 1..4;


    VAR
        #for [i] in 0..num_cars-1 {
            car[i] : car( #{from_dir[[i]]}, #{to_dir[[i]]}, #{speed[[i]]}, [i], #{acc_param}, #{dec_param} );
        }

    


    ASSIGN

    #for [i] in 0..num_cars-1 {
        #for [j] in 0..num_cars-1 {
            #if [j]!=[i] {
                next(car[i].decision[[j]]) := case
                    ((car[i].priority < car[j].priority) | 
                    (car[i].priority = car[j].priority & car[i].id > car[j].id)) & 
                    !car[j].EXITING &
                    conflict[car[i].from][car[i].to][car[j].from][car[j].to] > car[i].tcl_index &
                    (
                    #for CELLi in 1..4 {
                        #for CELLj in 1..4 {
                            (
                            conflict[car[i].from][car[i].to][car[j].from][car[j].to] = CELLi &
                            conflict[car[j].from][car[j].to][car[i].from][car[i].to] = CELLj &
                            --(car[i].timeAt_#{CELLi+1} + THETA > car[j].timeAt_CELLj) & 
                            --car[i].accelTimeAt_CELLi -THETA < car[j].timeAt_#{CELLj+1} -- i entra prima che j esca 
                            (
                            (car[i].accelTimeAt_CELLi - THETA > car[j].timeAt_CELLj & car[i].accelTimeAt_CELLi + THETA < car[j].timeAt_#{CELLj+1}) 
                            |
                            (car[j].timeAt_CELLj - THETA > car[i].accelTimeAt_CELLi & car[j].timeAt_CELLj + THETA < car[i].accelTimeAt_#{CELLi+1})
                            -- i entra prima che j esca 
                            )
                            ) |
                        }
                    } FALSE
                    ) 
                    : car[i].dec_param;

                    TRUE : car[i].acc_param;
                esac;
            }
        }
    }


    
    --#for [i] in 0..num_cars-1 {
    --    #for [j] in 0..num_cars-1 {
    --        #if [j]!=[i] {
    --            next(car[i].decision[[j]]) := case
    --                car[j].EXITING : car[i].acc_param;
    --                car[j].APPROACHING | car[j].CROSSING : case
    --                    conflict[car[i].from][car[i].to][car[j].from][car[j].to] = 0 : car[--i].acc_param;
    --                    conflict[car[i].from][car[i].to][car[j].from][car[j].to] != 0 : case
    --                        car[i].priority > car[j].priority | 
    --                        (car[i].id < car[j].id & car[i].priority = car[j].priority) : car[--i].acc_param;
    --                        TRUE : case
    --                            #for CELLi in 1..4 {
    --                                #for CELLj in 1..4 {
    --                                conflict[car[i].from][car[i].to][car[j].from][car[j].to] --= CELLi &
    --                                conflict[car[j].from][car[j].to][car[i].from][car[i].to] --= CELLj : case
    --                                    car[i].timeAt_#{CELLi+1} + THETA <= car[--j].timeAt_CELLj | 
    --                                    car[i].accelTimeAt_CELLi >= car[j].timeAt_#{CELLj+1} --+ THETA: car[i].acc_param;
    --                                    
    --                                    TRUE : car[i].dec_param;
    --                                    esac;
    --                                }
    --                            }
    --                            
    --                        esac;
    --                    esac; 
    --                esac;
    --            esac;
    --        }
    --    }
    --}
    

    


    

    DEFINE
        #for X in 0..(num_cars-2) {
            #for Y in (X+1)..(num_cars-1) {
                carXcarY_crash := (carX.CROSSING & carY.CROSSING & carX.position = carY.position );
            }
        }

        cars_exited := #list(&) Y in 0..(num_cars-1) { carY.EXITING };



    LTLSPEC
        -- safety: no crashes
        ! (
        G
        #for [i] in 0..num_cars-2 {
            #for [j] in [i]+1..num_cars-1 {
                !car[i]car[j]_crash &
                } TRUE
        }

        &
        
        -- liveness: cars eventually exits
        F cars_exited

        &

        -- safety: not every car stops
        G
        #for [i] in 0..num_cars-1 {
            car[i].speed != 0 |
        } FALSE
        
        &

        -- safety: non tutte decelerano
        G
        #for [i] in 0..num_cars-1 {
            car[i].acc >= 0 |
        } FALSE

        )




    --F (
    --#for [i] in 0..(num_cars-2) {
    --    #for [j] in ([i]+1)..(num_cars-1) { 
    --        car[i]car[j]_crash |
    --    }
    --} G !cars_exited)


MODULE car(from_in, to_in, speed_in, id_in, acc_in, dec_in)
    DEFINE

    lanes := #{lanes};
    max_tcl_index := lanes + 2;
    max_position := (lanes * lanes) + 1;
    max_speed := #{ max_speed };

    cell_progress := #{cell_progress}; -- progress to cross a cell.
    max_progress := cell_progress * max_tcl_index;  -- progress to cross the entire intersection.

    tcl_index := progress / cell_progress;
    position := tcl[tcl_index];
    t_max_speed := (max_speed - speed) / acc;
    t_null_speed := - speed / acc;
    t_max_speed_acc := (max_speed - speed) / acc_in;

    next_speed := max( min(speed + acc, max_speed), 0);
    next_speed_acc := max( min(speed + acc_in, max_speed), 0);


    #if num_cars == 2 {
        acc := min(decision[0], decision[1]); --TO BE GENERALIZED
    }
    #if num_cars == 3 {
        acc := min(min(decision[0], decision[1]), decision[2]); --TO BE GENERALIZED
    }

    acc_param := acc_in;
    dec_param := dec_in;


    #for CELL in 1..5 {
        timeAt_CELL := case
            #for T in 0..max_time {
                (T < t_max_speed & acc > 0 &
                        acc * T * (T+1) / 2 + speed * T + progress >=  CELL * cell_progress ) |
                (T >= t_max_speed & acc > 0 &
                        acc * t_max_speed * (t_max_speed+1) / 2 + speed * t_max_speed + 
                        (T-t_max_speed) * max_speed + progress >=  CELL * cell_progress) |
                (T <= t_null_speed & acc < 0 &
                        acc * T * (T+1) / 2 + speed * T + progress >=  CELL * cell_progress )
                : T;
            }
            TRUE : #{max_time};
        esac;
    }

    #for CELL in 1..5 {
        accelTimeAt_CELL := case
            #for T in 0..max_time {
                (T < t_max_speed_acc &
                        acc_in * T * (T+1) / 2 + next_speed_acc * T + progress >=  CELL * cell_progress ) |
                (T >= t_max_speed_acc &
                        acc_in * t_max_speed_acc * (t_max_speed_acc+1) / 2 + next_speed_acc * t_max_speed_acc + (T-t_max_speed_acc) * max_speed + progress >=  CELL * cell_progress)
                : T;
            }
            TRUE : #{max_time};
        esac;
    }


    APPROACHING := position <= 0;
    CROSSING := position > 0 & position < max_position;
    EXITING := position >= max_position;


    FROZENVAR
        id : 0..#{num_cars-1};
        tcl : array 0..max_tcl_index of 0..max_position;
        
        from : 0..3; --{ toP, BOTtoM, RIGHT, LEFT};
        to : 0..3; --{ toP, BOTtoM, RIGHT, LEFT};
        priority : 0..#{max_time};

    VAR
        --acc : { #{dec_param}, #{acc_param} };
        speed : 0..max_speed;
        progress : 0..max_progress;
        decision : array 0..(#{num_cars - 1}) of { #{dec_param}, #{acc_param} };

    ASSIGN
       #{ tcl_initialization2x2 }

        init(priority) := #{max_time} - timeAt_1;

       

        init(from) := from_in;
        init(to) := to_in;
        init(speed) := speed_in;
        init(id) := id_in;
        init(progress) := 0;

        next(progress) := case
            progress + next_speed <= max_progress : progress + next_speed;
            progress + next_speed > max_progress : max_progress;
        esac;

        next(speed) := next_speed;

            #for Index in 0..num_cars-1 {
                init(decision[Index]) := acc_in;
            }

        ---- The decision with respect to itself is always to accelerate
            next(decision[id_in]) := acc_in;
        