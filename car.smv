MODULE car(from_in, to_in, speed_in, distance_from_intersection)
	DEFINE
		-- size of the edge of each cell (meters)
		cell_size := 5;

		-- simulation step length (seconds)
		--dt := 0.1;

		-- number of lanes
		L := 2;

		-- max length of a tcl 
		len := 2*L - 1 - 1;

		-- simulation steps in a second
		steps_per_second := 10;

		-- max cell progress
		max_progress := 100;
		
		-- max speed (cell/max_progress per simulation step) (14m/s ~ 50 km/h)
		max_speed := (max_progress * 14) / (cell_size * steps_per_second);

	
	
	FROZENVAR
	-- forzenvars don't change in time

		-- trajectory cell list (list of vec2)
		tcl : array 0..len of array 0..1 of 1..L;
		
		-- list of time of arrival for each cell in tcl
		-- tcl_time : array 0..len of array 0..1 of 0..L;

		from : {BOTTOM, TOP, LEFT, RIGHT};
		to: {BOTTOM, TOP, LEFT, RIGHT};
	
	VAR
		-- current position in the intersection grid
		position : array 0..1 of 0..L;

		-- current speed in tenth of meters per second
		speed : 0..max_speed;
		
		-- fraction of cell traveled. Reals are not allowed.
		cell_progress : 0..max_progress;
		
		-- index pointing at current position in tcl
		tcl_index : 0..len;



	ASSIGN
		-- INITIALIZATIONS --
		init(from) := from_in;
		init(to) := to_in;
		
		-- using a Python script to generate tcl initialization (it's parametric)
		init(tcl[0][0]) := 2;
		init(tcl[0][1]) := 1;
		init(tcl[1][0]) := 2;
		init(tcl[1][1]) := 2;
		init(tcl[2][0]) := 1;
		init(tcl[2][1]) := 2;

		-- also position init is parametric in from and to
		init(position[0]) := tcl[0][0];
		init(position[1]) := tcl[0][1];
		init(speed) := speed_in;

		init(tcl_index) := 0;
		init(cell_progress) := 0;
		-- also tcl_time should be initialized with a script
		-- init(tcl_time) := get_initial_tcl_time(from, to, speed); -- pseudocode



		-- SIMULATION --
		next(speed) := speed;
		next(tcl_index) := case
			cell_progress + speed >  max_progress: min(tcl_index + 1, len);
			cell_progress + speed <= max_progress: tcl_index;
		esac;
		
		next(cell_progress) := case
			cell_progress + speed > max_progress : min(cell_progress + speed  - max_progress, max_progress);
			cell_progress + speed <= max_progress : min(cell_progress + speed, max_progress);
		esac;

		next(position[0]) := tcl[tcl_index][0];
		next(position[1]) := tcl[tcl_index][1];


MODULE main
	VAR
		c1 : car(BOTTOM, LEFT, 10, 0);
	SPEC
		AF (c1.position[0] = 1 & c1.position[1] = 1) 



