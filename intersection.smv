-- Planning...

-- The value of a define is visible in every preprocessing scope.
#define { num_cars = 2 }

MODULE intersection( #list [i] in 1..num_cars {car[i]} )

    DEFINE
        num_cars := #{num_cars}; -- emplace the value of 'num_cars' given during preprocessing step (inside define{ })
        accel := 1;
        decel := 0;

    FROZENVAR

    VAR

    ASSIGN 
        #for [i] in 1..num_cars {
            next(car[i].speed) := case
                car[i].speed + accel > car[i].max_speed : {car[i].speed - decel, car[i].speed};
                car[i].speed - decel < 0 : {car[i].speed, car[i].speed + accel};
               TRUE : {car[i].speed - decel, car[i].speed, car[i].speed + accel};
            esac;
        }
        --next(carIndex.speed) := carIndex.speed;

-----------------------------------------------------------------------------------------------------------------------

MODULE car(from_in, to_in, speed_in)

    DEFINE
        lanes := 2;
        max_tcl_index := lanes + 2;
        max_position := (lanes * lanes) + 1;
        max_speed := 30;
        max_progress := 100;

        position := tcl[tcl_index];

        APPROACHING := position <= 0;
        CROSSING := position > 0 & position < max_position;
        EXITING := position >= max_position;

    FROZENVAR
        tcl : array 0..max_tcl_index of 0..max_position;
        from : { TOP, BOTTOM, RIGHT, LEFT};
        to : { TOP, BOTTOM, RIGHT, LEFT};

    VAR
        tcl_index : 0..max_tcl_index;
        speed : 0..max_speed;
        progress : 0..max_progress;

    ASSIGN
        #insert_string {tcl_initialization2x2 }

        init(tcl_index) := 0;

        init(from) := from_in;
        init(to) := to_in;
        init(speed) := speed_in;
        init(progress) := 0;

        next(progress) := case
            EXITING &  progress + speed > max_progress : max_progress;
            progress + speed > max_progress : 0;
            progress + speed <= max_progress : progress+speed;
        esac;

        next(tcl_index) := case
            tcl_index != max_tcl_index & progress+speed > max_progress : tcl_index + 1;
            TRUE : tcl_index;
        esac;


MODULE main 
    VAR
        car1 : car(TOP, BOTTOM, 10);
        car2 : car(RIGHT, BOTTOM, 30);
        car3 : car(LEFT, RIGHT, 5);
        intersection : intersection( #list i in 1..num_cars {cari} );

    DEFINE
        #for X in 1..(num_cars-1) {
            #for Y in (X+1)..num_cars {
                carXcarY_crash := (carX.CROSSING & carY.CROSSING & carX.position = carY.position );
            }
        }


    CTLSPEC
        -- Planning:
        -- For each possible future, at some point a crash happens. Find me a counterexample.
        --AF (
        --#for X in 1..(num_cars-1) {
        --    #for Y in (X+1)..num_cars { 
        --        carXcarY_crash |
        --    }
        --} FALSE)

        -- Safety:
        -- There exist a possible future in which no crash happens (forever). Check this, without returning the plan.
        EG (
        #for X in 1..(num_cars-1) {
            #for Y in (X+1)..num_cars { 
                !carXcarY_crash &
            }
        } TRUE)

        -- Worth noticing: Planning = !Safety (by De Morgan's law)

